<!DOCTYPE html><HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8"><TITLE>Parser Combinators Tutorial</TITLE></HEAD><BODY><HEADER><P><EM>Drew Crampsie, Max Rottenkolber</EM></P><H1>Parser Combinators Tutorial</H1></HEADER><ASIDE><HEADER><H2>Table of contents</H2></HEADER><NAV><OL><LI><A HREF="#section-1">Introduction</A></LI><LI><A HREF="#section-2">How to combine parsers</A></LI><LI><A HREF="#section-3">Reading input</A></LI><LI><A HREF="#section-4">The three primitive parsers</A><OL><LI><A HREF="#section-4-1"><CODE>RESULT</CODE></A></LI><LI><A HREF="#section-4-2"><CODE>FAIL</CODE></A></LI><LI><A HREF="#section-4-3"><CODE>ITEM</CODE></A></LI></OL></LI><LI><A HREF="#section-5"><CODE>BIND</CODE>, our first combinator</A><OL><LI><A HREF="#section-5-1">A quick word on monads</A><OL><LI><A HREF="#section-5-1-1">The monad laws</A></LI></OL></LI></OL></LI><LI><A HREF="#section-6"><CODE>=SATISFIES</CODE>, the parser predicate</A><OL><LI><A HREF="#section-6-1">Example parsers for letters and numbers using <CODE>=SATISFIES</CODE></A></LI></OL></LI><LI><A HREF="#section-7"><CODE>PLUS</CODE>, the non-deterministic choice combinator</A><OL><LI><A HREF="#section-7-1">Example parsers using <CODE>PLUS</CODE></A></LI></OL></LI><LI><A HREF="#section-8">Syntax: <CODE>LET*</CODE> and the identity monad</A><OL><LI><A HREF="#section-8-1"><CODE>=LET*</CODE>, our version of <CODE>LET*</CODE> like do notation</A></LI><LI><A HREF="#section-8-2">Examples using =LET</A></LI></OL></LI><LI><A HREF="#section-9"><CODE>=OR</CODE>, <CODE>=AND</CODE>, <CODE>=IF</CODE>, <CODE>=WHEN</CODE>, <CODE>=UNLESS</CODE> and <CODE>=NOT</CODE>: Deterministic logic combinators</A><OL><LI><A HREF="#section-9-1">Examples using <CODE>=OR</CODE> and <CODE>=AND</CODE></A></LI></OL></LI><LI><A HREF="#section-10"><CODE>ZERO-OR-MORE</CODE> and <CODE>ONE-OR-MORE</CODE>: The repetition combinators</A><OL><LI><A HREF="#section-10-1">Examples using <CODE>ZERO-OR-MORE</CODE></A></LI></OL></LI><LI><A HREF="#section-11">Sources</A></LI></OL></NAV></ASIDE><ARTICLE><P>This tutorial is essentially a translation of Monadic Parser Combinators (see <A HREF="#section-11">#section-11</A>), or at least the first half, into common lisp. Discussion of static types and the details of monads are omitted as we are simply concerned with parsing.</P><P>The example code in the following document is completely self-contained, and does not require an installation of the smug library.</P><P>In some cases, the natural name for a parser conflicts with a name in the <CODE>COMMON-LISP</CODE> package. In those cases, rather then shadow the symbols, I have chosen to prefix those names with a <CODE>#\=</CODE> character. It is thought that this aids usability, as one can simply <CODE>(:use :smug)</CODE>.</P><P>No prior experience with functional programming, monads or recursive descent parsing is assumed. The only requirements are an ANSI Common Lisp environment, and a burning desire to find a better way to parse.</P><SECTION><HEADER ID="section-1"><H2>1 Introduction</H2></HEADER><P>The tutorial, like this library, is based on an approach to building parsers using higher-order functions (combinators) that is popular in the functional programming community. Incidentally, these parsers form an instance of something called a monad, which is itself a useful construct with implications beyond parsing.</P><P>With great debt to Monadic Parser Combinators, the paper from which this library is derived, this tutorial presents a step by step introduction to the topics of parser combinators and monads and their use in Common Lisp.</P></SECTION><SECTION><HEADER ID="section-2"><H2>2 How to combine parsers</H2></HEADER><P><I>A Parser for Things is a functions from Strings to Lists of Pairs of Things and Strings!</I> --- Fritz Ruehr, Willamette University <A HREF="http://www.willamette.edu/~fruehr/haskell/seuss.html">http://www.willamette.edu/~fruehr/haskell/seuss.html</A></P><P>A parser is something that is familiar to all programmers. A function that, given a series of tokens as input, produces a data structure that relates to the grammatical structure of the input in some way. Or, to put it simply, a function from strings to things.</P><FIGURE><PRE>(parse-thing "string") =&gt; #&lt;THING&gt;</PRE><FIGCAPTION>Our fictional parser matches the string <CODE>"string"</CODE> and returns an instance of <CODE>THING</CODE>.</FIGCAPTION></FIGURE><P>In order to combine simple parsers into larger more complex ones, they need a way to communicate between them. First, because any given parser might consume only a part of the input, we will have our parser return a <CODE>cons</CODE> with the result in the <CODE>CAR</CODE> and the remaining input in the <CODE>CDR</CODE>.</P><FIGURE><PRE>(parse-thing "string string") =&gt; (#&lt;THING&gt; . " string")</PRE><FIGCAPTION><CODE>PARSE-THING</CODE> retunrs a <CODE>cons</CODE> containing an instance of <CODE>THING</CODE> and the remaining input.</FIGCAPTION></FIGURE><P>Because a parser may return multiple results when the grammar is ambiguous, or may return no results all, we will put our conses in a list, and have the empty list, <CODE>NIL</CODE>, denote a failed parse.</P><FIGURE><PRE>(parse-thing "string string") =&gt; ((#&lt;THING&gt; . " string"))
(parse-thing "strong string") =&gt; NIL</PRE><FIGCAPTION>On failure <CODE>NIL</CODE> is returned.</FIGCAPTION></FIGURE><P>So, for our purposes, a parser is just a function that takes a single value as the input and returns a list of conses of results and unconsumed input.</P><P>It is this trivial protocol that allows us to combine small simple parsers into larger more useful ones.</P></SECTION><SECTION><HEADER ID="section-3"><H2>3 Reading input</H2></HEADER><P><I>Smug</I> parsers allow infinite look-ahead and backtracking. To support parsing many different things, it is useful to define an input protocol. <I>Smug</I> parsers only require three operations on input: <CODE>INPUT-FIRST</CODE>, <CODE>INPUT-REST</CODE> and <CODE>INPUT-EMPTY-P</CODE>. We will define them in terms of strings. This is not a particularly efficient implementation, but it serves our purposes.</P><FIGURE><PRE>(defmethod input-empty-p ((input string))  
  (zerop (length input)))

(defmethod input-first ((input string))
  (aref input 0))

(defmethod input-rest ((input string))
  (make-array (1- (length input))
    	       :displaced-to input
	       :displaced-index-offset 1
	       :element-type (array-element-type input)))

(input-empty-p "") =&gt; t
(input-empty-p "foo") =&gt; nil
(input-first "foo") =&gt; #\f
(input-rest "foo") =&gt; "oo"</PRE><FIGCAPTION>The input protocol.</FIGCAPTION></FIGURE></SECTION><SECTION><HEADER ID="section-4"><H2>4 The three primitive parsers</H2></HEADER><P>There are three simple primitive parsers. It it only necessary to understand them, and one sequencing combinator, <CODE>BIND</CODE>, to understand all of smug.</P><SECTION><HEADER ID="section-4-1"><H3>4.1 <CODE>RESULT</CODE></H3></HEADER><P>The first parser is <CODE>RESULT</CODE>, which always succeeds by returning the value passed to it, and does not consume any input. Because we have earlier defined parsers as functions that take a single argument we will curry the input parameter.</P><FIGURE><PRE>(defun result (value)
(lambda (input)
    (list (cons value input))))

(funcall (result :foo) "bar baz") =&gt; ((:foo . "bar baz"))</PRE><FIGCAPTION>Definition of <CODE>RESULT</CODE>.</FIGCAPTION></FIGURE></SECTION><SECTION><HEADER ID="section-4-2"><H3>4.2 <CODE>FAIL</CODE></H3></HEADER><P>The second parser, <CODE>FAIL</CODE>, is the inverse of <CODE>RESULT</CODE>. It simply fails regardless of the input. we could define <CODE>FAIL</CODE> as a function that takes a single argument, but then we would have to access it using <CODE>FUNCTION</CODE> (<CODE>#'</CODE>), and aesthetically that inconsistency is undesirable, so we will again curry the input parameter.</P><FIGURE><PRE>(defun fail ()
  (constantly nil))

(funcall (fail) "foo") =&gt; NIL</PRE><FIGCAPTION>Definition of <CODE>FAIL</CODE>.</FIGCAPTION></FIGURE></SECTION><SECTION><HEADER ID="section-4-3"><H3>4.3 <CODE>ITEM</CODE></H3></HEADER><P>The last true primitive is <CODE>ITEM</CODE>, which is a parser that consumes the first token in the input, or fails in the input is empty.</P><FIGURE><PRE>(defun item ()
  (lambda (input)
    (unless (input-empty-p input)
      (list (cons (input-first input)
                  (input-rest input))))))

(funcall (item) "foo") =&gt; ((#\f . "oo"))
(funcall (item) "") =&gt; NIL</PRE><FIGCAPTION>Definition of <CODE>ITEM</CODE>.</FIGCAPTION></FIGURE></SECTION></SECTION><SECTION><HEADER ID="section-5"><H2>5 <CODE>BIND</CODE>, our first combinator</H2></HEADER><P>Now that we have our primitive parsers, we need a way to combine them. We would like to be able to apply parsers in sequence, and it would also come in handy if we could give names to the intermediate results of parsers. Both these requirements are fulfilled by using the monadic sequencing operator, <CODE>BIND</CODE>.</P><P><CODE>BIND</CODE> is a function that takes as arguments a parser <CODE>P</CODE>, and a function <CODE>F</CODE> which takes a value and returns a parser <CODE>P2</CODE>. <CODE>BIND</CODE> returns a parser that first applies <CODE>P</CODE> to the input, returning a list of <CODE>(VALUE . INPUT)</CODE> pairs. The the function <CODE>F</CODE> is applied to each <CODE>VALUE</CODE>, and the result <CODE>P2</CODE> is then applied to the <CODE>INPUT</CODE>. The collected lists of pairs returned from the <CODE>P2</CODE>s are then concatenated and the result returned.</P><FIGURE><PRE>(defun bind (parser function)
  (lambda (input)
    (loop :for (value . input) :in (funcall parser input)
          :append (funcall (funcall function value) input))))

(let ((char-token
      (bind (item) 
	     (lambda (char) 
	       (result (list :char char))))))		
  (funcall char-token "foo"))
=&gt; (((:CHAR #\f) . "oo"))</PRE><FIGCAPTION>Definition of <CODE>BIND</CODE>.</FIGCAPTION></FIGURE><P>Because <CODE>BIND</CODE> itself returns a parser, the result of a <CODE>BIND</CODE> can be returned as <CODE>P2</CODE>. This allows parsers to be chained, and allows us to use <CODE>LAMBDA</CODE> to provide names for the values of parser results. For example, the following parser uses <CODE>BIND</CODE> to return the first two characters as a cons.</P><FIGURE><PRE>(let ((two-chars 
      (bind (item) 
	     (lambda (char) 
	       (bind (item) 
		     (lambda (char2) 
		       (result (cons char char2))))))))
  (funcall two-chars "asd"))
=&gt; (((#\a . #\s) . "d"))</PRE><FIGCAPTION>An example using <CODE>BIND</CODE>.</FIGCAPTION></FIGURE><P>The next section gets into some details about why our parser is a monad. You do not really need to know this, so feel free to skip to <A HREF="#section-6">#section-6</A> if you are in a hurry.</P><SECTION><HEADER ID="section-5-1"><H3>5.1 A quick word on monads</H3></HEADER><P>By virtue of having the functions <CODE>BIND</CODE> and <CODE>RESULT</CODE> defined as they are, our parser interface forms a monad. A monad is, essentially, a category of things that provide the functions <CODE>BIND</CODE> and <CODE>RESULT</CODE>.</P><P>Of course, just having functions called <CODE>BIND</CODE> and <CODE>RESULT</CODE> does not make a monad. There are other contracts that <CODE>BIND</CODE> (also known as pipe, <CODE>&gt;&gt;=</CODE>, <CODE>*</CODE>, or <CODE>let</CODE>) or <CODE>RESULT</CODE> (also known as lift, unit, return) must fulfill.</P><SECTION><HEADER ID="section-5-1-1"><H4>5.1.1 The monad laws</H4></HEADER><P>In order to be properly categorized as a monad, the thing providing definitions for <CODE>BIND</CODE> and <CODE>RESULT</CODE> must obey three laws (a static functional programmer would say "must have a certain type", but the word type means something different to a dynamic functional programmer, so we will avoid it here).</P><P>In order to describe those laws we need to define a few terms.</P><UL><LI><B>Monadic Value (MV):</B> A function that, given a value, returns a value in the form expected by the internals of <CODE>BIND</CODE>. In our examples above, a parser (taking an input and returning a list of results) is the Monadic Value. </LI><LI><B>Monadic Function (MF):</B> A function that, given a value returns a monadic value encapsulating that value. <CODE>RESULT</CODE> is the canonical Monadic Function.</LI></UL><P>In object-oriented terms, the MF is a constructor, and the MV an object.</P><P>The laws which all things must obey in order to be called a monad are simple:</P><UL><LI><I>Left identity</I>: <CODE>(bind (result x) MF) = (funcall MF x)</CODE></LI><LI><I>Right identity</I>: <CODE>(bind MV result) = MV</CODE></LI><LI><I>Associativity</I>: <CODE>(bind (bind MV MF) MF2) = (bind MV (lambda (x) (bind (MF x) MF2)))</CODE></LI></UL><P>With static type systems, the compiler will enforce this contract for you. In a dynamic system, we just need to be a little more careful. Proving the monad laws for our <CODE>BIND</CODE> and <CODE>RESULT</CODE> is left as an exercise.</P><P>That is really all there is to monads except for syntax, which we will get to later. There are extended laws that other monads obey, and monads have other uses beyond parsing, but we are reaching the end of our scope already.</P></SECTION></SECTION></SECTION><SECTION><HEADER ID="section-6"><H2>6 <CODE>=SATISFIES</CODE>, the parser predicate</H2></HEADER><P>Often, we only want to consume input if a certain condition is true. This where <CODE>=SATISFIES</CODE> comes in.</P><FIGURE><PRE>(defun =satisfies (predicate)
  (bind (item) 
        (lambda (x) 
	   (if (funcall predicate x)
	       (result x)
	       (fail)))))

(funcall (=satisfies #'digit-char-p) "1 and") =&gt; ((#\1 . " and"))</PRE><FIGCAPTION>Definition of <CODE>=SATISFIES</CODE>.</FIGCAPTION></FIGURE><P>If <CODE>PREDICATE</CODE> fails, so will the =SATISFIES parser. This is because <CODE>(bind (fail) MF)</CODE> will always fail. <CODE>FAIL</CODE>, also known as zero, is a function belonging to a category of monads knows as "monads with a zero". That is not terribly important for parsing, but interesting if you are into that sort of thing.</P><SECTION><HEADER ID="section-6-1"><H3>6.1 Example parsers for letters and numbers using <CODE>=SATISFIES</CODE></H3></HEADER><P><CODE>=SATISFIES</CODE> allows us to define some simple parsers.</P><FIGURE><PRE>(defun =char (x)
  (=satisfies (lambda (y) (eql x y))))

(defun =digit-char ()
  (=satisfies #'digit-char-p))

(defun lower-case-char ()
  (=satisfies #'lower-case-p))

(defun upper-case-char ()
  (=satisfies #'upper-case-p))

(funcall (=char #\x) "xyzzy") =&gt; ((#\x . "yzzy"))
(funcall (digit) "1234") =&gt; ((#\1 . "234"))
(funcall (lower-case-char) "abcd") =&gt; ((#\a . "bcd"))
(funcall (upper-case-char) "Abcd") =&gt; ((#\A . "bcd"))</PRE><FIGCAPTION>Definition of <CODE>=CHAR</CODE>, <CODE>=DIGIT-CHAR</CODE>, <CODE>LOWER-CASE-CHAR</CODE> and <CODE>UPPER-CASE-CHAR</CODE> in terms of <CODE>=SATISFIES</CODE>.</FIGCAPTION></FIGURE></SECTION></SECTION><SECTION><HEADER ID="section-7"><H2>7 <CODE>PLUS</CODE>, the non-deterministic choice combinator</H2></HEADER><P>If we want to combine our earlier parsers, say to create an <CODE>ALPHANUMERIC-CHAR</CODE> from <CODE>UPPER-CASE-CHAR</CODE> and <CODE>LOWER-CASE-CHAR</CODE>, we need a combinator capable of making the choice between them.</P><P>In some cases, it may not be an exclusive choice. There might be multiple ways to parse a string, or a later pass might resolve the ambiguity.</P><P>For example, in one of our earlier examples of <CODE>BIND</CODE>, we saw a parser that returned the first two characters in a stream. This parser will fail if there is only one character left in the input.</P><FIGURE><PRE>(let ((two-chars 
      (bind (item) 
	     (lambda (char) 
	       (bind (item) 
		     (lambda (char2) 
		       (result (cons char char2))))))))
  (funcall two-chars "a"))
=&gt; NIL</PRE><FIGCAPTION>Definition of <CODE>TWO-CHARS</CODE>.</FIGCAPTION></FIGURE><P>If we want to parse one or two characters, or an arbitrarily long series of characters, we need some way to express that.</P><P>Enter the <CODE>PLUS</CODE> combinator.</P><FIGURE><PRE>(defun plus (p1 p2)
 (lambda (input)
   (append (funcall p1 input) (funcall p2 input))))

(let ((two-chars
      (bind (item)
	     (lambda (char)
	       (bind (item)
		     (lambda (char2)
		       (result (cons char char2))))))))
 (funcall (plus two-chars (item)) "a")
 =&gt; ((#\a . ""))
 (funcall (plus two-chars (item)) "asd"))
 =&gt; (((#\a . #\s) . "d") (#\a . "sd"))</PRE><FIGCAPTION>Definition of <CODE>PLUS</CODE>.</FIGCAPTION></FIGURE><P>Note that the second parse returned two pairs, as both parsers were successful. The string parsed as both two chars and a single item.</P><SECTION><HEADER ID="section-7-1"><H3>7.1 Example parsers using <CODE>PLUS</CODE></H3></HEADER><P>The examples used in the original paper are for letters and alphanumeric characters. There is no good reason to use them over <CODE>(=satisfies #'alpha-char-p)</CODE> and the like, but they do serve as a simple example.</P><FIGURE><PRE>(defun letter () (plus (lower-case-char) (upper-case-char)))

(funcall (letter) "foo") =&gt; ((#\f . "oo"))
(funcall (letter) "1foo") =&gt; NIL

(defun alphanumeric () (plus (letter) (=digit-char)))

(funcall (alphanumeric) "1foo") =&gt; ((#\1 . "foo"))
(funcall (alphanumeric) "!1foo") =&gt; NIL</PRE><FIGCAPTION>Definition of <CODE>LETTER</CODE> and <CODE>ALPHANUMERIC</CODE>.</FIGCAPTION></FIGURE><P>The other example is more illustrative, a parser that returns a series of letters or the empty string.</P><FIGURE><PRE>(defun word ()
  (let ((non-empty-letters 
        (bind (letter) 
	        (lambda (first-letter) 
	          (bind (word)
		        (lambda (rest-of-letters)
		          (result (format nil "~A~A" 
			                  first-letter
					  rest-of-letters))))))))
    (plus non-empty-letters (result ""))))

(funcall (word) "asd")
=&gt;
(("asd" . "") ("as" . "d") ("a" . "sd") ("" . "asd"))</PRE><FIGCAPTION>Definition of <CODE>WORD</CODE>.</FIGCAPTION></FIGURE><P>This is our first recursive parser, but it is a common idiom. Notice that it returns all the possible strings of letters. This is obviously inefficient when one only requires the first value is required. A deterministic combinator =OR, will be introduced later in the tutorial.</P></SECTION></SECTION><SECTION><HEADER ID="section-8"><H2>8 Syntax: <CODE>LET*</CODE> and the identity monad</H2></HEADER><P>If you read the earlier section on monads, you would know that <CODE>BIND</CODE> and <CODE>RESULT</CODE> are the interface to many different types of monads, of which our parser is but one example. If you did not, you know now. Again, if you are not at all interested and really just want to keep on parsing, skip down to the definition of <CODE>=LET*</CODE> in <A HREF="#section-8-1">#section-8-1</A>.</P><P>The most basic monad is the identity monad. A definition of its <CODE>BIND</CODE> and <CODE>RESULT</CODE> might look like the following.</P><FIGURE><PRE>(defun i-bind (mv mf) (funcall mf mv))
(defun i-result (value) value)</PRE><FIGCAPTION>Definition of <CODE>I-BIND</CODE> and <CODE>I-RESULT</CODE>.</FIGCAPTION></FIGURE><P>In Lisp, the identity monad is so trivial as to be useless. In a functional programming language, or any language where the order of operations is not guaranteed, the identity monad serves to sequence operations.</P><P>Imagine a silly lisp where the order of evaluation is not defined as strict left to right (like say scheme). The following form could have disastrous consequences.</P><FIGURE><PRE>(progn (remove-gun-from-pants)
       (point-gun-at-bad-guy)
       (pull-trigger))</PRE><FIGCAPTION>Disastrous consequences!</FIGCAPTION></FIGURE><P>The identity monad makes the sequencing explicit. In a purely functional lisp, one might sequence the operations as follows.</P><FIGURE><PRE>(i-bind (remove-gun-from-pants) 
      (lambda (gun)
        (i-bind (point-gun-at-bad-guy gun)
	         (lambda (pointed-gun)
	           (i-bind (pull-trigger pointed-gun)
		           (lambda (fired-gun)
		             (i-result fired-gun)))))))</PRE><FIGCAPTION>Explicit sequencing with <CODE>I-BIND</CODE>.</FIGCAPTION></FIGURE><P>In functional programming languages this pattern is so common that there is special syntax for it. The usual choices are "do notation" or "list comprehension syntax".</P><P>First, the previous example rendered in list comprehension notation:</P><FIGURE><PRE>[fgun | gun &lt;- removeGun 
      , pgun &lt;- pointGunAtBadGuy gun
      , fgun &lt;- pullTrigger pgun] </PRE><FIGCAPTION>List comprehension notation in Haskell.</FIGCAPTION></FIGURE><P>And in do notation:</P><FIGURE><PRE>do 
  gun &lt;- removeGun 
  pgun &lt;- pointGunAtBadGuy
  fgun &lt;- pullTrigger pgun
  return fgun</PRE><FIGCAPTION>Do notation in Haskell.</FIGCAPTION></FIGURE><P>The astute lisper might notice that do notation looks a lot like <CODE>LET*</CODE>. In fact, that is really all it is. <CODE>LET*</CODE> is lisp syntax for the identity monad, and our <CODE>I-BIND</CODE> using forms above are directly translatable.</P><FIGURE><PRE>(let* ((gun (remove-gun-from-pants))
       (pointed-gun (point-gun-at-bad-guy gun))
       (fired-gun (pull-trigger pointed-gun)))
  (identity fired-gun))</PRE><FIGCAPTION>Common Lisps <CODE>LET*</CODE>.</FIGCAPTION></FIGURE><P>One could legitimately say that the common lisp package is an instance of the identity monad, if one cared for such insights.</P><SECTION><HEADER ID="section-8-1"><H3>8.1 <CODE>=LET*</CODE>, our version of <CODE>LET*</CODE> like do notation</H3></HEADER><P>A <CODE>LET*</CODE> like construct is the obvious notation for a lisper to take advantage of the monadic nature of parsers. It is often useful to ignore a value. In Haskell, the underscore character is used to denote an ignorable variable, so we will use the same convention.</P><FIGURE><PRE>(defmacro =let* (bindings &amp;body body)
  (if bindings
      (let ((symbol (first (first bindings))))
	  `(bind ,@(cdr (first bindings))
	         (lambda (,symbol)
		   ,@(when (string-equal (symbol-name symbol) "_")
		  	   `((declare (ignorable ,symbol))))
		   (=let* ,(cdr bindings)
		     ,@body))))
      `(progn ,@body)))</PRE><FIGCAPTION>Definition of <CODE>=LET*</CODE>.</FIGCAPTION></FIGURE><P>If we replace <CODE>BIND</CODE> with our <CODE>I-BIND</CODE> function above, we get a macro that is equivalent to <CODE>LET</CODE><B>. {=LET</B></P></SECTION><SECTION><HEADER ID="section-8-2"><H3>8.2 Examples using =LET</H3></HEADER><P>Using recursion like we did in our <CODE>WORD</CODE> parser, we will create a parser that matches a specific string.</P><FIGURE><PRE>(defun =string (string)
  (if (input-empty-p string)
      (result "")
      (=let* ((_ (=char (input-first string)))
	        (_ (=string (input-rest string))))
	  (result string))))

(funcall (=string "asdf")  "asdfjkl") =&gt; (("asdf" . "jkl"))
(funcall (=string "asdf")  "asd") =&gt; NIL</PRE><FIGCAPTION>Definition of <CODE>=STRING</CODE>.</FIGCAPTION></FIGURE><P>One can see how much nicer <CODE>=LET*</CODE> notation is, and also how the ignorable <CODE>_</CODE> comes in handy.</P></SECTION></SECTION><SECTION><HEADER ID="section-9"><H2>9 <CODE>=OR</CODE>, <CODE>=AND</CODE>, <CODE>=IF</CODE>, <CODE>=WHEN</CODE>, <CODE>=UNLESS</CODE> and <CODE>=NOT</CODE>: Deterministic logic combinators</H2></HEADER><P><CODE>=OR</CODE> is a deterministic <CODE>PLUS</CODE>. It takes any number of parsers. The first parser is run, and if it succeeds, evaluation short circuits and the result of the parser is returned. Otherwise, the next parser is run, and so on, until one succeeds or there are no more parsers.</P><P>We can not use <CODE>BIND</CODE> or <CODE>=LET*</CODE> for <CODE>=OR</CODE> because it would fail if one of its parsers fails. As such, <CODE>=OR</CODE> must be a primitive.</P><FIGURE><PRE>(defun =or (parser &amp;rest parsers)
  (lambda (input)
    (or (funcall parser input) 
        (when parsers 
	   (funcall (apply #'=or parsers) input)))))</PRE><FIGCAPTION>Definition of <CODE>=OR</CODE>.</FIGCAPTION></FIGURE><P>On the other hand, <CODE>=AND</CODE> can be defined in terms of <CODE>=LET*</CODE>, and does not even need to test for failure, as <CODE>BIND</CODE> handles failure automatically.</P><P><CODE>=AND</CODE> (known as <CODE>&gt;&gt;</CODE> in Haskell) sequentially composes parsers, discarding the results of all but the last one, and returning that result.</P><FIGURE><PRE>(defun =and (p1 &amp;rest ps)
  (=let* ((result p1))
    (if ps
	 (apply #'=and ps)
	 (result result))))</PRE><FIGCAPTION>Definition of <CODE>=AND</CODE>.</FIGCAPTION></FIGURE><P><CODE>=IF</CODE> is a primitive parser as well. It runs <CODE>TEST-PARSER</CODE> and depending on its success calls the <CODE>THEN-PARSER</CODE> or the <CODE>ELSE-PARSER</CODE> which defaults to <CODE>(FAIL)</CODE>.</P><FIGURE><PRE>(defun =if (test-parser then-parser &amp;optional (else-parser (fail)))
  (lambda (input)
    (if (funcall test-parser input)
	 (funcall then-parser input)
	 (funcall else-parser input))))</PRE><FIGCAPTION>Definition of <CODE>=IF</CODE>.</FIGCAPTION></FIGURE><P><CODE>=WHEN</CODE>, <CODE>=UNLESS</CODE> and <CODE>=NOT</CODE> can easily be defined in terms of <CODE>=IF</CODE>. <CODE>=WHEN</CODE> and <CODE>=UNLESS</CODE> behave like <CODE>=IF</CODE> without an <CODE>ELSE-PARSER</CODE> and with <CODE>(FAIL)</CODE> as the <CODE>THEN-PARSER</CODE> respectively. Both take an arbitrary amount of parses which are applied with <CODE>=AND</CODE>. <CODE>=NOT</CODE> runs <CODE>(ITEM)</CODE> only when <CODE>PARSER</CODE> fails.</P><FIGURE><PRE>(defun =when (test-parser &amp;rest parsers)
  (=if test-parser (apply #'=and parsers)))

(defun =unless (test-parser &amp;rest parsers)
  (=if test-parser (fail) (apply #'=and parsers)))

(defun =not (parser)
  (=if parser (fail) (item)))</PRE><FIGCAPTION>Definitions of <CODE>=WHEN</CODE>, <CODE>=UNLESS</CODE> and <CODE>=NOT</CODE>.</FIGCAPTION></FIGURE><SECTION><HEADER ID="section-9-1"><H3>9.1 Examples using <CODE>=OR</CODE> and <CODE>=AND</CODE></H3></HEADER><P>The <CODE>MAYBE</CODE> combinator, which allows a parser to fail and still continue, is a natural use of <CODE>=OR</CODE>.</P><FIGURE><PRE>(defun maybe (parser)
  (=or parser (result nil)))</PRE><FIGCAPTION>Definition of <CODE>MAYBE</CODE>.</FIGCAPTION></FIGURE><P>Using <CODE>=AND</CODE>, we can implement <CODE>=PROG1</CODE> (which comes in handy for matching things and the end of the line, or when there is no more input) and <CODE>=PROG2</CODE>, which as we will see is also quite useful.</P><FIGURE><PRE>(defun =prog1 (parser &amp;rest parsers)
  (=let* ((result parser)
	   (_ (apply #'=and parsers)))
    (result result)))

(defun =prog2 (parser1 parser2 &amp;rest parsers)
  (=and parser1 (apply #'=prog1 parser2 parsers)))</PRE><FIGCAPTION>Definitions of <CODE>=PROG1</CODE> and <CODE>=PROG2</CODE>.</FIGCAPTION></FIGURE></SECTION></SECTION><SECTION><HEADER ID="section-10"><H2>10 <CODE>ZERO-OR-MORE</CODE> and <CODE>ONE-OR-MORE</CODE>: The repetition combinators</H2></HEADER><P>Earlier, we defined a parser, <CODE>WORD</CODE>, using <CODE>BIND</CODE> and a recursive call. Let us define a similar parser using <CODE>=LET*</CODE> that returns a list of letters.</P><FIGURE><PRE>(defun letters ()
  (=or (=let* ((x (letter))
	        (xs (letters)))
	  (result (cons x xs)))
       (result nil)))</PRE><FIGCAPTION>Definition of <CODE>LETTERS</CODE>.</FIGCAPTION></FIGURE><P>This pattern can easily be abstracted into a more general combinator, <CODE>ZERO-OR-MORE</CODE>.</P><FIGURE><PRE>(defun zero-or-more (parser)
  (=or (=let* ((x parser)
	        (xs (zero-or-more parser)))
	  (result (cons x xs)))
       (result nil)))

(funcall (zero-or-more (=char #\a)) "aaaab")
=&gt; (((#\a #\a #\a #\a) . "b"))

(funcall (zero-or-more (=char #\a)) "bbbba")
=&gt; ((NIL . "bbbba"))</PRE><FIGCAPTION>Definition of <CODE>ZERO-OR-MORE</CODE>.</FIGCAPTION></FIGURE><P>Note that zero or more always succeeds. If one needs a parser that matches one or more items and fails otherwise, we can define one in terms of <CODE>ZERO-OR-MORE</CODE> and can call it, appropriately enough, <CODE>ONE-OR-MORE</CODE>.</P><FIGURE><PRE>(defun one-or-more (parser)
  (=let* ((x parser)
	   (y (zero-or-more parser)))
    (result (cons x y))))

(funcall (one-or-more (=char #\a)) "aaaab")
=&gt; (((#\a #\a #\a #\a) . "b"))

(funcall (one-or-more (=char #\a)) "bbbba")
=&gt; NIL</PRE><FIGCAPTION>Definition of <CODE>ONE-OR-MORE</CODE>.</FIGCAPTION></FIGURE><SECTION><HEADER ID="section-10-1"><H3>10.1 Examples using <CODE>ZERO-OR-MORE</CODE></H3></HEADER><P>First, lets make a parser for standard quoted strings. We will use the <CODE>#\'</CODE> character as the quotes, and the <CODE>#\|</CODE> character as the escape character, simply to make it easier to embed in our example text in common lisp strings.</P><FIGURE><PRE>(defun quoted-string (&amp;key (quote (=char #\'))
                           (escape (=char #\|)))					 
  (let ((escaped-char (=and escape (item)))
	  (string-char (=and (=not quote) (item))))
    (=let* ((chars (=prog2 (=char #\') 
			     (zero-or-more
			      (=or escaped-char
				   string-char))
			     (=char #\'))))
      (result (coerce chars 'string)))))

(funcall (quoted-string)
	   "'The quote char is |' and the escape char is ||.'")
=&gt; (("The quote char is ' and the escape char is |." . ""))</PRE><FIGCAPTION>Definition of <CODE>QUOTED-STRING</CODE>.</FIGCAPTION></FIGURE></SECTION></SECTION><SECTION><HEADER ID="section-11"><H2>11 Sources</H2></HEADER><UL><LI>Monadic parser combinators (pdf, ps, bibtex) Graham Hutton and Erik Meijer. Technical Report <CODE>NOTTCS-TR-96-4</CODE>, Department of Computer Science, University of Nottingham, 1996. <A HREF="http://www.cs.nott.ac.uk/~gmh/bib.html#monparsing">http://www.cs.nott.ac.uk/~gmh/bib.html#monparsing</A></LI></UL></SECTION></ARTICLE></BODY></HTML>