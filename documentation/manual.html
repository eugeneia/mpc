<!DOCTYPE html><HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8"><TITLE>Smug manual</TITLE></HEAD><BODY><HEADER><H1>Smug manual</H1></HEADER><ASIDE><HEADER><H2>Table of contents</H2></HEADER><NAV><OL><LI><A HREF="#section-1">Abstract</A></LI><LI><A HREF="#section-2"><CODE>RUN</CODE>: Main entry point.</A></LI><LI><A HREF="#section-3">Primitive parsers and combinators</A></LI><LI><A HREF="#section-4"><CODE>=LET*</CODE>: Syntax for lispers</A></LI><LI><A HREF="#section-5">Error handling</A></LI><LI><A HREF="#section-6">More combinators</A></LI><LI><A HREF="#section-7">Parsers for character input</A></LI><LI><A HREF="#section-8">Parsers for numerals</A></LI></OL></NAV></ASIDE><ARTICLE><SECTION><HEADER ID="section-1"><H2>1 Abstract</H2></HEADER><P>Smug is a monadic parser combinators library. It provides a toolbox of predefined parsers, facilities for error handling and parses arrays, streams and lists.</P><P>This is the manual for the packages <CODE>smug</CODE>, <CODE>smug.characters</CODE>, and <CODE>smug.numerals</CODE>. Refer to <A HREF="api.html">api.html</A> for detailed documentation of external symbols. To learn more about <CODE>smug</CODE>'s internals and monadic parser combinators in general read <A HREF="parser-combinators-tutorial.html">parser-combinators-tutorial.html</A>.</P></SECTION><SECTION><HEADER ID="section-2"><H2>2 <CODE>RUN</CODE>: Main entry point.</H2></HEADER><P><CODE>RUN</CODE> is the main entry point to <CODE>SMUG</CODE> and has to be used to run a parser against input.</P></SECTION><SECTION><HEADER ID="section-3"><H2>3 Primitive parsers and combinators</H2></HEADER><P>The core of <CODE>smug</CODE> is made up of primitive parsers and combinators. A parser is a function that accepts an input source and returns a list of pairs containing the result and the remaining input. A combinator is a function which returns a parser. For consistency primitive parsers are defined as combinators that that always return the same parser.</P><P><CODE>ITEM</CODE> is used to pop off an item from input. It fails when input is empty. <CODE>RESULT</CODE> always succeeds with a given value without consuming input. It is used to return anything but <CODE>(ITEM)</CODE> from a parser. To check for end of input there is <CODE>END-OF-INPUT</CODE> which succeeds only when input is empty.</P><P>The primitive combinator <CODE>BIND</CODE> permits applying parsers in sequence and3 offers a way to access their intermediate results. <CODE>PLUS</CODE> lets us combine parsers in a non-deterministic way while <CODE>=OR</CODE> and <CODE>=AND</CODE> are deterministic alternatives. <CODE>=IF</CODE> allows for conditional application of parsers.</P></SECTION><SECTION><HEADER ID="section-4"><H2>4 <CODE>=LET*</CODE>: Syntax for lispers</H2></HEADER><P>The <CODE>=LET*</CODE> macro offers a lispy syntax for <CODE>BIND</CODE>. It also offers a way to ignore intermediate values.</P></SECTION><SECTION><HEADER ID="section-5"><H2>5 Error handling</H2></HEADER><P><CODE>FAIL</CODE> simply always fails. It optionally accepts expressions to be evaluated at failure. Those expressions are permitted to call <CODE>GET-INPUT-POSITION</CODE>, which can be used to determine where a failure occurred.</P><P>Two other error handling facilities <CODE>=HANDLER-CASE</CODE> and <CODE>=RESTART-CASE</CODE> do what their names suggest.</P></SECTION><SECTION><HEADER ID="section-6"><H2>6 More combinators</H2></HEADER><P><CODE>=WHEN</CODE> and <CODE>=UNLESS</CODE> combine parsers as if by <CODE>=AND</CODE> if their condition parser succeeds or fails respectively. <CODE>=NOT</CODE> applies <CODE>(ITEM)</CODE> to input only when its condition parser fails.</P><P><CODE>=PROG1</CODE> and <CODE>=PROG2</CODE> behave like <CODE>=AND</CODE> but return the result of the first or second parser respectively. <CODE>MAYBE</CODE> applies a parser and succeeds even if the parser fails.</P><P><CODE>=SATISFIES</CODE> applies <CODE>(ITEM)</CODE> but only succeeds when the result returned by <CODE>(ITEM)</CODE> satisfies a given predicate. <CODE>=EQL</CODE>, <CODE>ONE-OF</CODE>, <CODE>NONE-OF</CODE> and <CODE>RANGE</CODE> are like <CODE>=SATISFIES</CODE> but require the result returned by <CODE>(ITEM)</CODE> to be <CODE>EQL</CODE> to a given value, <CODE>EQL</CODE> to one or no value in a given list or to fall inside a range defined by a predicate and a lower and upper bound respectively.</P><P><CODE>ONE-OR-MORE</CODE>, <CODE>ZERO-OR-MORE</CODE>, <CODE>ONE-TO</CODE>, <CODE>ZERO-TO</CODE>, <CODE>AT-LEAST</CODE> and <CODE>EXACTLY</CODE> do as their names suggest and <CODE>BIND</CODE> a parser multiple successive times in various variants.</P><P><CODE>=FUNCALL</CODE> applies a parser and returns the result of a given function instead of the parser's result.</P></SECTION><SECTION><HEADER ID="section-7"><H2>7 Parsers for character input</H2></HEADER><P><CODE>=CHARACTER</CODE> behaves like <CODE>=EQL</CODE> but uses <CODE>CHAR=</CODE> instead of <CODE>EQL</CODE>. <CODE>=STRING</CODE> is similar too as it parses a given string or fails. <CODE>STRING-OF</CODE> parses a string of characters parsed by a given parser.</P><P><CODE>WHITESPACE</CODE> and <CODE>SKIP-WHITESPACE</CODE> parse or skip characters commonly considered as whitespace respectively. <CODE>NEWLINE</CODE> parses the newline character and <CODE>LINE</CODE> parses a string of characters terminated by newline or end of input.</P></SECTION><SECTION><HEADER ID="section-8"><H2>8 Parsers for numerals</H2></HEADER><P><CODE>DIGIT</CODE> parses a number from a digit character. <CODE>NATURAL-NUMBER</CODE> and <CODE>INTEGER-NUMBER</CODE> both parse numbers from numeral strings while the latter also understands a leading dash for negativity. All three parses accept an optional radix argument.</P></SECTION></ARTICLE></BODY></HTML>